"""
Proposal data model for agent-generated suggestions.

All agents emit proposals (not allocations) that require human approval.
"""

from datetime import datetime, timezone
from enum import Enum
from typing import Any, Dict, List, Optional
from pydantic import BaseModel, Field, ConfigDict
import uuid


class ProposalType(str, Enum):
    """Types of proposals agents can generate"""
    MATCH = "match"  # Mutual aid matchmaker
    CACHE_EVICTION = "cache_eviction"  # Commons router
    CACHE_PRIORITY = "cache_priority"  # Commons router
    FORWARDING_POLICY = "forwarding_policy"  # Commons router
    URGENT_EXCHANGE = "urgent_exchange"  # Perishables dispatcher
    BATCH_COOKING = "batch_cooking"  # Perishables dispatcher
    WORK_PARTY = "work_party"  # Scheduler
    SEASONAL_PLAN = "seasonal_plan"  # Permaculture planner
    PROCESS_SEQUENCE = "process_sequence"  # Permaculture planner
    LEARNING_PATH = "learning_path"  # Education pathfinder
    REPLENISHMENT = "replenishment"  # Inventory agent
    SHORTAGE_WARNING = "shortage_warning"  # Inventory agent


class ProposalStatus(str, Enum):
    """Lifecycle status of a proposal"""
    PENDING = "pending"  # Awaiting review
    APPROVED = "approved"  # Approved by required parties
    REJECTED = "rejected"  # Rejected by any required party
    EXPIRED = "expired"  # TTL expired before approval
    EXECUTED = "executed"  # Successfully executed after approval


class Proposal(BaseModel):
    """
    A proposal generated by an agent.

    Proposals include explanation, inputs used, constraints, and require
    human approval before execution.
    """
    proposal_id: str = Field(default_factory=lambda: f"prop:{uuid.uuid4()}")
    agent_name: str = Field(description="Name of agent that created proposal")
    proposal_type: ProposalType

    # Core content
    title: str = Field(description="Short title of proposal")
    explanation: str = Field(
        description="Human-readable rationale (1-3 sentences)"
    )

    # Transparency fields (non-negotiable)
    inputs_used: List[str] = Field(
        description="Array of bundleIds or data sources that informed decision"
    )
    constraints: List[str] = Field(
        description="Relevant limitations (dietary, access, privacy, timing)"
    )

    # Proposal data (type-specific)
    data: Dict[str, Any] = Field(
        description="Type-specific proposal data (e.g., match details, plan steps)"
    )

    # Approval tracking
    requires_approval: List[str] = Field(
        description="List of user IDs that must approve"
    )
    approvals: Dict[str, bool] = Field(
        default_factory=dict,
        description="Map of user_id -> approved/rejected"
    )
    approval_reasons: Dict[str, str] = Field(
        default_factory=dict,
        description="Optional reasons for approval/rejection"
    )

    # Metadata
    status: ProposalStatus = ProposalStatus.PENDING
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    expires_at: Optional[datetime] = None
    executed_at: Optional[datetime] = None

    # Bundle reference (once published)
    bundle_id: Optional[str] = None

    def is_fully_approved(self) -> bool:
        """Check if all required approvals are granted"""
        if not self.requires_approval:
            return True
        return all(
            self.approvals.get(user_id, False)
            for user_id in self.requires_approval
        )

    def is_rejected(self) -> bool:
        """Check if any required party rejected"""
        return any(
            self.approvals.get(user_id) is False
            for user_id in self.requires_approval
        )

    def add_approval(self, user_id: str, approved: bool, reason: Optional[str] = None):
        """Record an approval or rejection"""
        if user_id not in self.requires_approval:
            raise ValueError(f"User {user_id} not in required approvers")

        self.approvals[user_id] = approved
        if reason:
            self.approval_reasons[user_id] = reason

        # Update status
        if approved and self.is_fully_approved():
            self.status = ProposalStatus.APPROVED
        elif not approved:
            self.status = ProposalStatus.REJECTED

    def mark_executed(self):
        """Mark proposal as executed"""
        if self.status != ProposalStatus.APPROVED:
            raise ValueError("Can only execute approved proposals")
        self.status = ProposalStatus.EXECUTED
        self.executed_at = datetime.now(timezone.utc)

    def to_bundle_payload(self) -> Dict[str, Any]:
        """Convert proposal to DTN bundle payload"""
        return {
            "type": "agent-proposal",
            "proposal": self.model_dump(mode="json")
        }

    model_config = ConfigDict()


class ProposalFilter(BaseModel):
    """Filter criteria for querying proposals"""
    agent_name: Optional[str] = None
    proposal_type: Optional[ProposalType] = None
    status: Optional[ProposalStatus] = None
    user_id: Optional[str] = Field(
        None,
        description="Filter to proposals requiring this user's approval"
    )
    created_after: Optional[datetime] = None
    created_before: Optional[datetime] = None
